/*
 *  Copyright (C) 2006-2017 Leandro Nini
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "ttaBackend.h"

#include "settings.h"
#include "tag.h"

#include <QDebug>
#include <QLabel>

// created by reswrap from file tta.gif
extern const unsigned char iconTta[612] =
{
    0x47,0x49,0x46,0x38,0x39,0x61,0x10,0x00,0x10,0x00,0xc6,0x41,0x00,0xbc,0xbc,0xc3,
    0xbd,0xbd,0xc4,0xbe,0xbe,0xc6,0xbe,0xbe,0xc7,0xbf,0xbf,0xc9,0xc0,0xc0,0xcc,0xc1,
    0xc1,0xcd,0xc2,0xc2,0xcf,0xc2,0xc2,0xd0,0xc4,0xc4,0xd2,0xc4,0xc4,0xd4,0xc5,0xc5,
    0xd5,0xc6,0xc6,0xd6,0xc6,0xc6,0xd7,0xc7,0xc7,0xd9,0xc8,0xc8,0xd9,0xc8,0xc8,0xdb,
    0xca,0xca,0xdd,0xcb,0xcb,0xdf,0xcc,0xcc,0xe0,0xcd,0xcd,0xe2,0xce,0xce,0xe3,0xcf,
    0xcf,0xe5,0xd0,0xd0,0xe6,0xd1,0xd1,0xe6,0xd1,0xd1,0xe8,0xd2,0xd2,0xe8,0xd3,0xd3,
    0xe9,0xd3,0xd3,0xea,0xd4,0xd4,0xea,0xd5,0xd5,0xeb,0xd7,0xd7,0xed,0xd7,0xd7,0xee,
    0xd8,0xd8,0xee,0xd9,0xd9,0xef,0xd9,0xd9,0xf0,0xda,0xda,0xf0,0xdb,0xdb,0xf1,0xdc,
    0xdc,0xf2,0xdd,0xdd,0xf3,0xde,0xde,0xf4,0xe0,0xe0,0xf5,0xe1,0xe1,0xf5,0xe2,0xe2,
    0xf6,0xe4,0xe4,0xf7,0xe5,0xe5,0xf8,0xe6,0xe6,0xf9,0xe7,0xe7,0xf9,0xe8,0xe8,0xf9,
    0xe9,0xe9,0xf9,0xea,0xea,0xfa,0xeb,0xeb,0xfb,0xec,0xec,0xfb,0xed,0xed,0xfb,0xf0,
    0xf0,0xfc,0xf0,0xf0,0xfd,0xf1,0xf1,0xfd,0xf2,0xf2,0xfd,0xf3,0xf3,0xfd,0xf5,0xf5,
    0xfd,0xf6,0xf6,0xfd,0xf7,0xf7,0xfd,0xfc,0xfc,0xfe,0xfd,0xfd,0xff,0xfe,0xfe,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x21,0xf9,0x04,
    0x01,0x0a,0x00,0x7f,0x00,0x2c,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x07,
    0xc1,0x80,0x7f,0x82,0x83,0x7f,0x31,0x2d,0x84,0x88,0x82,0x33,0x34,0x32,0x30,0x2c,
    0x2a,0x28,0x24,0x89,0x7f,0x34,0x33,0x8b,0x32,0x2e,0x2b,0x27,0x24,0x1d,0x88,0x35,
    0x34,0x34,0x39,0x3c,0x3a,0x31,0x9a,0x23,0x1d,0x16,0x83,0xa0,0x35,0x3b,0x40,0x40,
    0x3d,0x34,0x9a,0x21,0x1c,0x15,0x10,0x82,0x32,0x33,0x3a,0x41,0x41,0x3e,0x37,0x2f,
    0x29,0x26,0x1f,0x1a,0x14,0x0f,0x82,0x2f,0x32,0x3c,0x41,0x3f,0x39,0x2f,0xa6,0x1e,
    0x17,0x12,0x0d,0x7f,0x2a,0x2c,0x30,0x36,0x3d,0x38,0x30,0x2b,0x28,0x25,0x1f,0x1b,
    0x14,0x10,0x0a,0x06,0x27,0x2b,0x2c,0x2f,0x31,0x2e,0x90,0x25,0x20,0x1d,0x17,0x11,
    0x0c,0x08,0x04,0x7f,0x29,0x2a,0x2a,0x2b,0x29,0x27,0xeb,0x1d,0x18,0x14,0x0e,0x09,
    0x05,0x82,0x4a,0x9c,0x18,0x58,0x42,0xc4,0x87,0x7d,0xe0,0xfe,0x0d,0x10,0xe4,0x21,
    0x84,0x88,0x10,0x1f,0x3c,0x6c,0xb8,0x30,0x21,0x9c,0x81,0x01,0x01,0x06,0x6d,0xe0,
    0xc0,0x21,0xc3,0x05,0x0a,0x11,0xfc,0x5d,0x14,0x80,0x68,0x02,0x05,0x90,0x0f,0x16,
    0x28,0x24,0x99,0x88,0x41,0x03,0x95,0x07,0x08,0x08,0x00,0x30,0x89,0x90,0xcc,0x49,
    0x81,0x00,0x00,0x3b
};

#define EXT "tta"

#define CREDITS "TTA Player Library\nVersion 2.2\nCopyright \302\251 1999-2014 Alexander Djourik."
#define LINK    "http://tta.sourceforge.net/"

const char ttaBackend::name[] = "True Audio";

#define PCM_BUFFER_SIZE 5184

using namespace tta;

/*****************************************************************/

size_t ttaBackend::fillBuffer(void* buffer, const size_t bufferSize, const unsigned int seconds)
{
    size_t n = 0;

    do {
        if (_bufOffset>=_bufSize)
        {
            try
            {
                _bufSize = TTA->process_stream(_decodeBuf, PCM_BUFFER_SIZE)*_sampleSize;
            }
            catch (tta_exception& ex)
            {
                qWarning() << "Error " << getError(ex.code());
                return 0;
            }
            if (!_bufSize)
                break;

            _bufOffset = 0;
        }

        const size_t size = qMin((size_t)(_bufSize-_bufOffset), bufferSize-n);
        memcpy((char*)buffer+n, (char*)_decodeBuf+_bufOffset, size);
        _bufOffset += size;
        n += size;

    } while (n<bufferSize);

    return n;
}

/*****************************************************************/

const char* ttaBackend::getError(const TTA_CODEC_STATUS e)
{
    switch(e)
    {
    case TTA_OPEN_ERROR: return "Can't open file\n";
    case TTA_FORMAT_ERROR: return "Not compatible file format\n";
    case TTA_FILE_ERROR: return "File is corrupted\n";
    case TTA_READ_ERROR: return "Can't read from input file\n";
    case TTA_WRITE_ERROR: return "Can't write to output file\n";
    case TTA_MEMORY_ERROR: return "Insufficient memory available\n";
    case TTA_SEEK_ERROR: return "File seek error\n";
    case TTA_PASSWORD_ERROR: return "Password protected file\n";
    case TTA_NOT_SUPPORTED: return "Unsupported architecture\n";
    case TTA_NO_ERROR:
    default: return "Unknown error\n";
    }
}

bool ttaBackend::supports(const QString& fileName)
{
    QRegExp rx("*." EXT);
    rx.setPatternSyntax(QRegExp::Wildcard);
    return rx.exactMatch(fileName);
}

inline QStringList ttaBackend::ext() const { return QStringList(EXT); }

ttaBackend::ttaBackend() :
    inputBackend(name, iconTta) {}

ttaBackend::~ttaBackend()
{
    close();
}

bool ttaBackend::open(const QString& fileName)
{
    close();

    _file.setFileName(fileName);
    if (!_file.open(QIODevice::ReadOnly))
        return false;

    const tag tagPtr(&_file);

    _metaData.addInfo(metaData::TITLE, tagPtr.title());
    _metaData.addInfo(metaData::ARTIST, tagPtr.artist());
    _metaData.addInfo(metaData::ALBUM, tagPtr.album());
    _metaData.addInfo(metaData::GENRE, tagPtr.genre());
    _metaData.addInfo(metaData::YEAR, tagPtr.year());
    _metaData.addInfo(gettext("publisher"), tagPtr.publisher());
    _metaData.addInfo(metaData::TRACK, tagPtr.track());
    _metaData.addInfo(metaData::COMMENT, tagPtr.comment());
    _metaData.addInfo(tagPtr.image());

    _file.seek(0);

    io.iocb.read = &read_callback;
    io.iocb.seek = &seek_callback;
    io.iocb.write = NULL;
    io.handle = &_file;

    TTA = new tta_decoder((TTA_io_callback*)&io);
    //set_password(void const *pstr, TTAuint32 len);

    try
    {
            TTA->init_get_info(&_info, 0);
    }
    catch (tta_exception& ex)
    {
        qWarning() << "Error " << getError(ex.code());
        return false;
    }

    _sampleSize = _info.nch*(_info.bps/8);

    _decodeBuf = new TTAuint8[PCM_BUFFER_SIZE*_sampleSize];

    time(_info.samples/_info.sps);

    _bufOffset = 0;
    _bufSize = 0;

    songLoaded(fileName);
    return true;
}

void ttaBackend::close()
{
    if (songLoaded().isEmpty())
        return;

    delete TTA;
    delete [] _decodeBuf;
    _file.close();
    songLoaded(QString::null);
}

bool ttaBackend::rewind()
{
    try
    {
            TTAuint32 new_pos;
            TTA->set_position(0, &new_pos);
    }
    catch (tta_exception& ex)
    {
        qWarning() << "Error " << getError(ex.code());
        return false;
    }

    _bufOffset = 0;
    _bufSize = 0;
    return true;
}

TTAint32 CALLBACK ttaBackend::read_callback(TTA_io_callback *io, TTAuint8 *buffer, TTAuint32 size)
{
    const tta_wrapper* iocb = (tta_wrapper*)io;
    return ((QFile*)iocb->handle)->read((char*)buffer, size);
}

TTAint64 CALLBACK ttaBackend::seek_callback(TTA_io_callback *io, TTAint64 offset)
{
    const tta_wrapper* iocb = (tta_wrapper*)io;
    return ((QFile*)iocb->handle)->seek(offset);
}

/*****************************************************************/

ttaConfig::ttaConfig(QWidget* win) :
    configFrame(win, ttaBackend::name, CREDITS, LINK)
{
    matrix()->addWidget(new QLabel(tr("No settings available"), this));
}
